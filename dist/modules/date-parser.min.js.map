{"version":3,"sources":["date-parser.min.js","helpers/date-parser.js"],"names":["angular","module","provider","$localeProvider","ParseDate","this","year","month","day","hours","minutes","seconds","milliseconds","noop","isNumeric","n","isNaN","parseFloat","isFinite","indexOfCaseInsensitive","array","value","len","length","str","toString","toLowerCase","i","prototype","setMilliseconds","setSeconds","setMinutes","setHours","getHours","setDate","setMonth","setFullYear","fromDate","getFullYear","getMonth","getDate","getMinutes","getSeconds","getMilliseconds","toDate","Date","proto","defaults","format","strict","$get","$locale","dateFilter","DateParserFactory","config","setMapForFormat","keys","Object","setFnMap","map","sortedMap","clonedFormat","split","index","search","join","forEach","v","push","escapeReservedSymbols","text","replace","regExpForFormat","regExpMap","re","RegExp","regex","setMap","options","extend","$dateParser","sss","ss","s","mm","m","HH","H","hh","h","a","EEEE","DATETIME_FORMATS","DAY","EEE","SHORTDAY","dd","d","MMMM","MONTH","MMM","SHORTMONTH","MM","M","yyyy","yy","y","match","init","$format","isValid","date","isDate","getTime","test","parse","baseDate","timezone","formatRegex","formatSetMap","matches","exec","call","newDate","parseInt","getDateForAttribute","key","today","isString","substr","Infinity","getTimeForAttribute","time","daylightSavingAdjust","timezoneOffsetAdjust","undo","getTimezoneOffset"],"mappings":"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","file":"date-parser.min.js","sourcesContent":[null,"'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function($localeProvider) {\r\n\r\n  // define a custom ParseDate object to use instead of native Date\r\n  // to avoid date values wrapping when setting date component values\r\n  function ParseDate() {\r\n    this.year = 1970;\r\n    this.month = 0;\r\n    this.day = 1;\r\n    this.hours = 0;\r\n    this.minutes = 0;\r\n    this.seconds = 0;\r\n    this.milliseconds = 0;\r\n  }\r\n\r\n  ParseDate.prototype.setMilliseconds = function(value) { this.milliseconds = value; };\r\n  ParseDate.prototype.setSeconds = function(value) { this.seconds = value; };\r\n  ParseDate.prototype.setMinutes = function(value) { this.minutes = value; };\r\n  ParseDate.prototype.setHours = function(value) { this.hours = value; };\r\n  ParseDate.prototype.getHours = function() { return this.hours; };\r\n  ParseDate.prototype.setDate = function(value) { this.day = value; };\r\n  ParseDate.prototype.setMonth = function(value) { this.month = value; };\r\n  ParseDate.prototype.setFullYear = function(value) { this.year = value; };\r\n  ParseDate.prototype.fromDate = function(value) {\r\n    this.year = value.getFullYear();\r\n    this.month = value.getMonth();\r\n    this.day = value.getDate();\r\n    this.hours = value.getHours();\r\n    this.minutes = value.getMinutes();\r\n    this.seconds = value.getSeconds();\r\n    this.milliseconds = value.getMilliseconds();\r\n    return this;\r\n  };\r\n\r\n  ParseDate.prototype.toDate = function() {\r\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\r\n  };\r\n\r\n  var proto = ParseDate.prototype;\r\n\r\n  function noop() {\r\n  }\r\n\r\n  function isNumeric(n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  function indexOfCaseInsensitive(array, value) {\r\n    var len = array.length, str=value.toString().toLowerCase();\r\n    for (var i=0; i<len; i++) {\r\n      if (array[i].toLowerCase() === str) { return i; }\r\n    }\r\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function(config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\r\n        'MMM'   : function(value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\r\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : proto.setFullYear\r\n      };\r\n\r\n      var regex, setMap;\r\n\r\n      $dateParser.init = function() {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function(date) {\r\n        if(angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function(value, baseDate, format, timezone) {\r\n        // check for date format special names\r\n        if(format) format = $locale.DATETIME_FORMATS[format] || format;\r\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if(!matches) return false;\r\n        // use custom ParseDate object to set parsed values\r\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\r\n        for(var i = 0; i < matches.length - 1; i++) {\r\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\r\n        }\r\n        // convert back to native Date object\r\n        var newDate = date.toDate();\r\n\r\n        // check new native Date object for day values overflow\r\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\r\n          return false;\r\n        }\r\n\r\n        return newDate;\r\n      };\r\n\r\n      $dateParser.getDateForAttribute = function(key, value) {\r\n        var date;\r\n\r\n        if(value === 'today') {\r\n          var today = new Date();\r\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\r\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\r\n          date = new Date(value.substr(1, value.length - 2));\r\n        } else if(isNumeric(value)) {\r\n          date = new Date(parseInt(value, 10));\r\n        } else if (angular.isString(value) && 0 === value.length) { // Reset date\r\n          date = key === 'minDate' ? -Infinity : +Infinity;\r\n        } else {\r\n          date = new Date(value);\r\n        }\r\n\r\n        return date;\r\n      };\r\n\r\n      $dateParser.getTimeForAttribute = function(key, value) {\r\n        var time;\r\n\r\n        if(value === 'now') {\r\n          time = new Date().setFullYear(1970, 0, 1);\r\n        } else if(angular.isString(value) && value.match(/^\".+\"$/)) {\r\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\r\n        } else if(isNumeric(value)) {\r\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\r\n        } else if (angular.isString(value) && 0 === value.length) { // Reset time\r\n          time = key === 'minTime' ? -Infinity : +Infinity;\r\n        } else {\r\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\r\n        }\r\n\r\n        return time;\r\n      };\r\n\r\n      /* Handle switch to/from daylight saving.\r\n      * Hours may be non-zero on daylight saving cut-over:\r\n      * > 12 when midnight changeover, but then cannot generate\r\n      * midnight datetime, so jump to 1AM, otherwise reset.\r\n      * @param  date  (Date) the date to check\r\n      * @return  (Date) the corrected date\r\n      *\r\n      * __ copied from jquery ui datepicker __\r\n      */\r\n      $dateParser.daylightSavingAdjust = function(date) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\r\n        return date;\r\n      };\r\n\r\n      /* Correct the date for timezone offset.\r\n      * @param  date  (Date) the date to adjust\r\n      * @param  timezone  (string) the timezone to adjust for\r\n      * @param  undo  (boolean) to add or subtract timezone offset\r\n      * @return  (Date) the corrected date\r\n      */\r\n      $dateParser.timezoneOffsetAdjust = function(date, timezone, undo) {\r\n        if (!date) {\r\n          return null;\r\n        }\r\n        // Right now, only 'UTC' is supported.\r\n        if (timezone && timezone === 'UTC') {\r\n          date = new Date(date.getTime());\r\n          date.setMinutes(date.getMinutes() + (undo?-1:1)*date.getTimezoneOffset());\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function setMapForFormat(format) {\r\n        var keys = Object.keys(setFnMap), i;\r\n        var map = [], sortedMap = [];\r\n        // Map to setFn\r\n        var clonedFormat = format;\r\n        for(i = 0; i < keys.length; i++) {\r\n          if(format.split(keys[i]).length > 1) {\r\n            var index = clonedFormat.search(keys[i]);\r\n            format = format.split(keys[i]).join('');\r\n            if(setFnMap[keys[i]]) {\r\n              map[index] = setFnMap[keys[i]];\r\n            }\r\n          }\r\n        }\r\n        // Sort result map\r\n        angular.forEach(map, function(v) {\r\n          // conditional required since angular.forEach broke around v1.2.21\r\n          // related pr: https://github.com/angular/angular.js/pull/8525\r\n          if(v) sortedMap.push(v);\r\n        });\r\n        return sortedMap;\r\n      }\r\n\r\n      function escapeReservedSymbols(text) {\r\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function regExpForFormat(format) {\r\n        var keys = Object.keys(regExpMap), i;\r\n\r\n        var re = format;\r\n        // Abstract replaces to avoid collisions\r\n        for(i = 0; i < keys.length; i++) {\r\n          re = re.split(keys[i]).join('${' + i + '}');\r\n        }\r\n        // Replace abstracted values\r\n        for(i = 0; i < keys.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\r\n        }\r\n        format = escapeReservedSymbols(format);\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n"],"sourceRoot":"/source/"}